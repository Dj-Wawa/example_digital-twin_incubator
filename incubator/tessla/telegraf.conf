
[agent]
interval = "1s"
flush_interval = "1s"

[[inputs.amqp_consumer]]
	brokers = ["amqp://localhost:5672"]
	username = "incubator"
	password = "incubator"
	exchange = "Incubator_AMQP"
	exchange_durability = "transient"
	queue = "telegraf"
	queue_durability = "transient"
	binding_key = "incubator.diagnosis.plant.lidopen"
	data_format = "json"
	json_string_fields = ["lid_open"]

[[inputs.amqp_consumer]]
	brokers = ["amqp://localhost:5672"]
	username = "incubator"
	password = "incubator"
	exchange = "Incubator_AMQP"
	exchange_durability = "transient"
	queue = "telegraf"
	queue_durability = "transient"
	binding_key = "incubator.energysaver.status"
	data_format = "json"
	json_string_fields = ["energy_saver_on"]

[[outputs.amqp]]
	brokers = ["amqp://localhost:5672"]
	username = "incubator"
	password = "incubator"
	exchange = "Incubator_AMQP"
	exchange_durability = "transient"
	routing_key = "incubator.update.closed_loop_controller.parameters"
	namepass = ["result"]
	data_format = "json"
	use_batch_format = false
	
	
[[outputs.file]]
	files = ["stdout"]

[[processors.starlark]]
  source = '''
# Die apply-Funktion wird f체r jede Metrik aufgerufen, die durchl채uft.
def apply(metric):
    # Extrahieren des Wertes des 'value'-Feldes.
    value = metric.fields.get('value')
    
    # Erstellen eines neuen, leeren Metrik-Objekts mit demselben Namen und denselben Tags.
    new_metric = Metric(metric.name)

    # Entscheidungslogik basierend auf dem Wert von 'value'.
    if value == True:
        new_metric.fields['temperature_desired'] = 21
    else:
        new_metric.fields['temperature_desired'] = 37
    
    # Das urspr체ngliche Metrik-Objekt wird ignoriert und das neue Metrik-Objekt zur체ckgegeben.
    return new_metric
'''

	namepass= ["result"]

[[outputs.influxdb]]
  urls = ["udp://127.0.0.1:1653"]
[[inputs.socket_listener]]
  service_address = "udp://:1654"
  data_format = "influx"
